using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Control code for the the player's game object.
/// Very approximate simulation of flight dynamics.
/// </summary>
public class PlayerControl : MonoBehaviour {
    /// <summary>
    /// Coefficient of draft for head winds
    /// </summary>
    [Header("Aerodynamic coefficients")]
    public float ForwardDragCoefficient = 0.01f;
    /// <summary>
    /// Drag coefficient for winds blowing up/down across wings
    /// </summary>
    public float VerticalDragCoefficient = 0.5f;
    /// <summary>
    /// Lift generated by the wings
    /// </summary>
    public float LiftCoefficient = 0.01f;

    /// <summary>
    /// How far the plane can tilt around the X axis
    /// </summary>
    [Header("Movement Speeds")]
    public float PitchRange = 45f;
    /// <summary>
    /// How far the plane can rotate about the Z axis
    /// </summary>
    public float RollRange = 45;
    /// <summary>
    /// How fast the plane yaws for a given degree of roll.
    /// </summary>
    public float RotationalSpeed = 5f;
    /// <summary>
    /// Thrust generated when the throttle is pulled back all the way.
    /// </summary>
    public float MaximumThrust = 20f;

    /// <summary>
    /// Text element for displaying status information
    /// </summary>
    [Header("HUD")]
    public Text StatusDisplay;
    /// <summary>
    /// Text element for displaying game-over text
    /// </summary>
    public Text GameOverText;

    /// <summary>
    /// Cached copy of the player's RigidBody component
    /// </summary>
    private Rigidbody playerRB;


    /// <summary>
    /// Magic layer mask code for the updraft(s)
    /// </summary>
    const int UpdraftLayerMask = 1 << 8;


    #region Internal flight state
    /// <summary>
    /// Current yaw (rotation about the Y axis)
    /// </summary>
    private float yaw;
    /// <summary>
    /// Current pitch (rotation about the X axis)
    /// </summary>
    private float pitch;
    /// <summary>
    /// Current roll (rotation about the Z axis)
    /// </summary>
    private float roll;
    /// <summary>
    /// Current thrust (forward force provided by engines
    /// </summary>
    private float thrust;
    #endregion


    private LandingPlatform LP;

    private Updraft upDraftObj;

    private BoxCollider boxcol; 

    /// <summary>
    /// Initialize component
    /// </summary>
    internal void Start() {
        playerRB = GetComponent<Rigidbody>();
        playerRB.velocity = transform.forward*3;

        // Get these game objects now so we don't have too later
        LP = FindObjectOfType<LandingPlatform>();
        upDraftObj = FindObjectOfType<Updraft>();
        boxcol = FindObjectOfType<BoxCollider>(); 
    }

    /// <summary>
    /// Show game-over display
    /// </summary>
    /// <param name="safe">True if we won, false if we crashed</param>
    private void OnGameOver(bool safe) {
        playerRB.velocity = Vector3.zero;
        playerRB.useGravity = false;
        playerRB.constraints = RigidbodyConstraints.FreezeAll;
        if (safe) {
            GameOverText.text = "You Win!";
        } else {
            GameOverText.text = "OOPS";
        }
    }

    /// <summary>
    /// Display status information
    /// </summary>
    internal void OnGUI()
    {
        StatusDisplay.text = string.Format("Speed: {0:00.00}    altitude: {1:00.00}    Thrust {2:0.0}",
            playerRB.velocity.magnitude,
            transform.position.y,
            thrust);
    }


    private void FixedUpdate()
    {
        // get our axis's of rotation
        float horizontalMovement = Input.GetAxis("Horizontal");
        float verticalMovement = Input.GetAxis("Vertical");
        float forwardMovement = Input.GetAxis("Thrust");



        // figure out what our thrust value should be
        if (forwardMovement < 0)
        {
           forwardMovement = 0; 
        }

        thrust = forwardMovement;
        thrust = thrust * MaximumThrust;
        playerRB.AddForce(transform.forward * thrust);


        // Assign our roll,pitch, and raw to our new values
        roll = Mathf.Lerp(horizontalMovement * RollRange, horizontalMovement, 0.01f);
        float newYawValue = -roll * RotationalSpeed * Time.deltaTime; 
        yaw += Mathf.Lerp(newYawValue, -roll, 0.01f);
        pitch = Mathf.Lerp(verticalMovement * PitchRange, verticalMovement, 0.01f);


        // Make the player actually rotate
        Quaternion newQuaternion = Quaternion.Euler(pitch, yaw, roll);
        playerRB.MoveRotation(newQuaternion);




        Collider[] newArr = Physics.OverlapSphere(transform.position, boxcol.size.x / 2, UpdraftLayerMask);
        Vector3 v = -playerRB.velocity; 

        if (newArr.Length >= 1)
        {
            v = upDraftObj.WindVelocity - playerRB.velocity; 
        }

        // Math for the various drags
        float v2f = Vector3.Dot(v, transform.forward);
        float v2f2 = v2f; 
        v2f = v2f * v2f;
        Vector3 liftDrag = LiftCoefficient * v2f * transform.up;
        playerRB.AddForce(liftDrag); 
        

        float var1 = Mathf.Sign(v2f2);
        float var2 = v2f2;

        playerRB.AddForce(var1 * ForwardDragCoefficient * (var2 * var2) * transform.forward);

        float vUp = Vector3.Dot(v, transform.up);
        float var3 = Mathf.Sign(vUp);


        Vector3 verticalDrag = var3 * VerticalDragCoefficient * Mathf.Pow(vUp, 2) * transform.up;
        playerRB.AddForce(verticalDrag); 


        LayerMask updraftLayer = LayerMask.GetMask("Updrafts");
        Vector3 windVelocity = FindObjectOfType<Updraft>().WindVelocity;
      
        
    }


    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.name == "LandingPlatform" && playerRB.velocity.magnitude < LP.MaxLandingSpeed)
        {
            OnGameOver(true);
        }
        else
        {
            OnGameOver(false);
        }

    }


}
